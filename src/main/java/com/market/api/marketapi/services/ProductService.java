package com.market.api.marketapi.services;

import DTO.DtoMapper;
import DTO.ProductDTO;
import com.market.api.marketapi.models.Product;
import com.market.api.marketapi.models.Sale;
import com.market.api.marketapi.repositories.ProductRepository;
import com.market.api.marketapi.repositories.SaleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import com.market.api.marketapi.exception.*;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import lombok.RequiredArgsConstructor;
import org.springframework.transaction.annotation.Transactional;

/**
 * Service layer for managing Product entities.
 * Provides CRUD operations and revenue calculation methods.
 *
 * Author: Anugrah Balakrishnan
 * Date Modified: 28 July 2024
 */
@Service
@RequiredArgsConstructor
public class ProductService {

    @Autowired
    private SaleService saleService; // Inject SaleService
    @Autowired
    private ProductRepository productRepository;
    @Autowired
    private SaleRepository saleRepository;

    /**
     * Retrieves all products with pagination.
     *
     * @param pageable Pagination information
     * @return Page of Product entities
     */
    public Page<Product> getAllProducts(Pageable pageable) {
        return productRepository.findAll(pageable);
    }

    /**
     * Retrieves a product by its ID.
     *
     * @param id ID of the product
     * @return Optional of ProductDTO if found, empty if not
     */
    public Optional<ProductDTO> getProductById(Long id) {
        return productRepository.findById(id)
                .map(DtoMapper::toProductDTO);
    }

    /**
     * Adds a new product.
     *
     * @param product Product entity to add
     * @return The saved Product entity
     */
    public Product addProduct(Product product) {
        return productRepository.save(product);
    }

    /**
     * Deletes a product by its ID.
     *
     * @param id ID of the product to delete
     */
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
    }

    /**
     * Calculates the total revenue from all sales.
     *
     * @return Total revenue as a Double
     */
    public Double getTotalRevenue() {
        return saleRepository.findAll().stream()
                .mapToDouble(sale -> {
                    Product product = sale.getProduct();
                    return sale.getQuantity() * (product != null ? product.getPrice() : 0.0);
                })
                .sum();
    }

    /**
     * Calculates the revenue generated by a specific product.
     *
     * @param productId ID of the product
     * @return Revenue generated by the product as a Double
     */
    public Double getRevenueByProduct(Long productId) {
        return saleRepository.findAll().stream()
                .filter(sale -> sale.getProduct() != null && sale.getProduct().getId().equals(productId))
                .mapToDouble(sale -> sale.getQuantity() * sale.getProduct().getPrice())
                .sum();
    }

    /**
     * Saves a product from a ProductDTO.
     *
     * @param productDTO ProductDTO to save
     * @return Saved ProductDTO
     */
    public ProductDTO saveProduct(ProductDTO productDTO) {
        // Convert DTO to Entity
        Product product = DtoMapper.toProduct(productDTO);

        // Save product to DB
        Product savedProduct = productRepository.save(product);
        // Convert saved product back to DTO
        return DtoMapper.toProductDTO(savedProduct);
    }

    /**
     * Updates an existing product.
     *
     * @param productId      ID of the product to update
     * @param updatedProduct Updated Product entity with new data
     * @return Updated Product entity
     * @throws ResourceNotFoundException if product with given ID is not found
     */
    @Transactional
    public Product updateProduct(Long productId, Product updatedProduct) {
        return productRepository.findById(productId)
                .map(existingProduct -> {
                    // Update product fields
                    if (updatedProduct.getName() != null) {
                        existingProduct.setName(updatedProduct.getName());
                    }
                    if (updatedProduct.getPrice() != null) {
                        existingProduct.setPrice(updatedProduct.getPrice());
                    }
                    if (updatedProduct.getDescription() != null) {
                        existingProduct.setDescription(updatedProduct.getDescription());
                    }
                    if (updatedProduct.getQuantity() != null) {
                        existingProduct.setQuantity(updatedProduct.getQuantity());
                    }
                    // Update associated sales
                    updateSales(existingProduct, updatedProduct.getSales());
                    return productRepository.save(existingProduct);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + productId));
    }

    /**
     * Updates sales associated with a product.
     *
     * @param existingProduct Existing Product entity
     * @param updatedSales    Updated list of Sales entities
     */
    private void updateSales(Product existingProduct, List<Sale> updatedSales) {
        // Remove existing sales not in the updated list
        existingProduct.getSales().removeIf(existingSale -> updatedSales.stream()
                .noneMatch(updatedSale -> Objects.equals(updatedSale.getId(), existingSale.getId())));

        // Add or update sales
        for (Sale updatedSale : updatedSales) {
            existingProduct.getSales().stream()
                    .filter(existingSale -> Objects.equals(existingSale.getId(), updatedSale.getId()))
                    .findFirst()
                    .ifPresentOrElse(existingSale -> {
                        // Update existing sale
                        existingSale.setSaleDate(updatedSale.getSaleDate());
                        existingSale.setQuantity(updatedSale.getQuantity());
                        existingSale.setSalePrice(updatedSale.getSalePrice());
                    }, () -> {
                        // Add new sale
                        Sale newSale = new Sale();
                        newSale.setSaleDate(updatedSale.getSaleDate());
                        newSale.setQuantity(updatedSale.getQuantity());
                        newSale.setSalePrice(updatedSale.getSalePrice());
                        existingProduct.addSale(newSale);
                    });
        }
    }
}
