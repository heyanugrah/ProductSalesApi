package com.market.api.marketapi.services;

import com.market.api.marketapi.DTO.DtoMapper;
import com.market.api.marketapi.DTO.ProductDTO;
import com.market.api.marketapi.models.Product;
import com.market.api.marketapi.models.Sale;
import com.market.api.marketapi.repositories.ProductRepository;
import com.market.api.marketapi.repositories.SaleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import com.market.api.marketapi.exception.*;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import lombok.RequiredArgsConstructor;
import org.springframework.transaction.annotation.Transactional;

import javax.swing.text.html.Option;

/**
 * Service layer for managing Product entities.
 * Provides CRUD operations and revenue calculation methods.
 *
 * Author: Anugrah Balakrishnan
 * Date Modified: 28 July 2024
 */
@Service
@RequiredArgsConstructor
public class ProductService {

    @Autowired
    private SaleService saleService; // Inject SaleService
    @Autowired
    private ProductRepository productRepository;
    @Autowired
    private SaleRepository saleRepository;

    /**
     * Retrieves all products with pagination.
     *
     * @param pageable Pagination information
     * @return Page of Product entities
     */
    public Page<Product> getAllProducts(Pageable pageable) {
        return productRepository.findAll(pageable);
    }

    /**
     * Retrieves a product by its ID.
     *
     * @param id ID of the product
     * @return Optional of ProductDTO if found, empty if not
     */
    public Optional<ProductDTO> getProductById(Long id) {
        return productRepository.findById(id)
                .map(DtoMapper::toProductDTO);
    }

    /**
     * Adds a new product.
     *
     * @param product Product entity to add
     * @return The saved Product entity
     */
    public Product addProduct(Product product) {
        return productRepository.save(product);
    }

    /**
     * Deletes a product by its ID.
     *
     * @param id ID of the product to delete
     */
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
    }

    /**
     * Calculates the total revenue from all sales.
     *
     * @return Total revenue as a Double
     */
    public Double getTotalRevenue() {
        return saleRepository.findAll().stream()
                .mapToDouble(sale -> {
                    Product product = sale.getProduct();
                    return sale.getQuantity() * (product != null ? product.getPrice() : 0.0);
                })
                .sum();
    }

    /**
     * Calculates the revenue generated by a specific product.
     *
     * @param productId ID of the product
     * @return Revenue generated by the product as a Double
     */
    public Double getRevenueByProduct(Long productId) {
        return saleRepository.findAll().stream()
                .filter(sale -> sale.getProduct() != null && sale.getProduct().getId().equals(productId))
                .mapToDouble(sale -> sale.getQuantity() * sale.getProduct().getPrice())
                .sum();
    }

    /**
     * Saves a product from a ProductDTO.
     *
     * @param productDTO ProductDTO to save
     * @return Saved ProductDTO
     */
    public ProductDTO saveProduct(ProductDTO productDTO) {
        // Convert DTO to Entity
        Product product = DtoMapper.toProduct(productDTO);

        // Save product to DB
        Product savedProduct = productRepository.save(product);
        // Convert saved product back to DTO
        return DtoMapper.toProductDTO(savedProduct);
    }

    /**
     * Updates an existing product.
     *
     * @param productId      ID of the product to update
     * @param productDTO Updated Product entity with new data
     * @return Updated Product entity
     * @throws ResourceNotFoundException if product with given ID is not found
     */
    @Transactional
    public Product updateProduct(Long productId, ProductDTO productDTO) {

        // Convert DTO to Entity
        Product mappedProduct = DtoMapper.toProduct(productDTO);

        return productRepository.findById(productId)
                .map(existingProduct -> {
                    // Update product fields
                    if (mappedProduct.getName() != null) {
                        existingProduct.setName(mappedProduct.getName());
                    }
                    if (mappedProduct.getPrice() != null) {
                        existingProduct.setPrice(mappedProduct.getPrice());
                    }
                    if (mappedProduct.getDescription() != null) {
                        existingProduct.setDescription(mappedProduct.getDescription());
                    }
                    if (mappedProduct.getQuantity() != null) {
                        existingProduct.setQuantity(mappedProduct.getQuantity());
                    }
                    // Update associated sales
                    updateSales(existingProduct, mappedProduct.getSales());
                    return productRepository.save(existingProduct);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + productId));
    }

    /**
     * Updates sales associated with a product.
     *
     * @param existingProduct Existing Product entity
     * @param updatedSales    Updated list of Sales entities
     */
    private void updateSales(Product existingProduct, List<Sale> updatedSales)
    {
        // Add or update sales
        // Iterate through each updated sale
        for (Sale updatedSale : updatedSales) {
            // Check if there is an existing sale with the same ID
            existingProduct.getSales().stream()
                    .filter(existingSale -> Objects.equals(existingSale.getId(), updatedSale.getId()))
                    .findFirst()
                    .ifPresentOrElse(existingSale -> {
                        // If an existing sale is found, update its details
                        existingSale.setSaleDate(updatedSale.getSaleDate());
                        existingSale.setQuantity(updatedSale.getQuantity());
                        existingSale.setSalePrice(updatedSale.getSalePrice());
                    }, () -> {
                        // If no matching sale is found, add the new sale to the product
                        Sale newSale = new Sale();
                        newSale.setSaleDate(updatedSale.getSaleDate());
                        newSale.setQuantity(updatedSale.getQuantity());
                        newSale.setSalePrice(updatedSale.getSalePrice());
                        existingProduct.addSale(newSale);
                    });

        }
    }
}
